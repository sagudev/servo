name: Main

on:
  push:
    branches:
      # Run the entire pipeline for 'main' even though the merge queue already runs checks
      # for every change. This just offers an extra layer of testing and covers the case of
      # random force pushes.
      - "main"
      # For try runs
      - "try"
  pull_request:
    types: ['opened', 'synchronize']
    branches: ["**"]
  merge_group:
    types: [checks_requested]
  workflow_call:
    inputs:
      configuration:
        required: true
        type: string
  workflow_dispatch:
    inputs:
      profile:
        required: false
        default: "release"
        type: choice
        options: ["release", "debug", "production"]
      wpt-tests-to-run:
        default: ""
        required: false
        type: string
      platform:
        required: false
        type: choice
        options: ["linux", "windows", "macos", "all"]
      wpt-layout:
        required: false
        type: choice
        options: ["none", "2013", "2020", "all"]
      unit-tests:
        required: false
        type: boolean

jobs:
  decision:
    name: Decision
    runs-on: ubuntu-20.04
    outputs:
      configuration: ${{ steps.configuration.outputs.result }}
    steps:
      - name: Configuration
        id: configuration
        uses: actions/github-script@v6
        with:
          script: |
            // If this is a workflow call with a configuration object,
            // then just return it immediately.
            let configuration = ${{ inputs.configuration || '""' }};
            if (configuration != "") {
              console.log("Using configuration: " + JSON.stringify(configuration));
              return configuration;
            }

            if (context.eventName == "pull_request") {
              return {
                "fail_fast": false,
                "matrix": [
                  {
                    "os": "linux",
                    "name": "Linux",
                    "wpt_layout": "none",
                    "profile": "release",
                    "unit_tests": true,
                    "wpt_tests_to_run": "",
                  },
                ],
              };
            }

            // try runs can have config in last commit msg
            if (${{ github.ref_name == 'try' }}) {
              let commit_msg = context.payload.head_commit.message;
              try {
                var o = JSON.parse(commit_msg.split('\n').slice(-1));

                if (o && typeof o === "object") {
                  console.log("Using try commit configuration: " + JSON.stringify(o));
                  return o;
                }
              }
              catch (e) { } // try with bad commit msg will do full run
            }

            // If we reach here we are likely doing full run
            configuration = {
              "fail_fast": false,
              "matrix": [
                {
                  "os": "linux",
                  "name": "Linux",
                  "wpt_layout": "all",
                  "profile": "release",
                  "unit_tests": true,
                  "wpt_tests_to_run": "",
                },
                {
                  "os": "windows",
                  "name": "Windows",
                  "wpt_layout": "none", // not used
                  "profile": "release",
                  "unit_tests": true,
                  "wpt_tests_to_run": "",
                },
                {
                  "os": "mac",
                  "name": "MacOS",
                  "wpt_layout": "none",
                  "profile": "release",
                  "unit_tests": true,
                  "wpt_tests_to_run": "",
                }
              ],
            };

            // Make merge queue fast
            if (context.eventName == "merge_group") {
              configuration.fail_fast = true;
            }

            // user provided overrides of full run
            if (context.eventName == "workflow_dispatch") {
              // only linux-wpt
              configuration.matrix[0].wpt_layout = "${{ inputs.wpt-layout }}" || "none";
              configuration.matrix[0].wpt_tests_to_run = "${{ inputs.wpt-tests-to-run }}" || "";

              let unit_tests = Boolean(${{ inputs.unit-tests }});
              let profile = '${{ inputs.profile }}';
              for (const platform of configuration.matrix) {
                platform.profile = profile;
                platfrom.unit_tests = unit_tests;
              }
            }

            console.log("Using configuration: " + JSON.stringify(configuration));
            return configuration;

  build:
    needs: ["decision"]
    name: ${{ matrix.name }}
    strategy:
      fail-fast: ${{ fromJson(needs.decision.outputs.configuration).fail_fast }}
      matrix:
        include: ${{ fromJson(needs.decision.outputs.configuration).matrix }}
    # we need dipatch os because workflows do not support uses: ${}
    uses: ./.github/workflows/dispatch-os.yml
    secrets: inherit
    with:
      os: ${{ matrix.os }}
      wpt-layout: ${{ matrix.wpt_layout }}
      profile: ${{ matrix.profile }}
      unit-tests: ${{ matrix.unit_tests }}
      wpt-tests-to-run: ${{ matrix.wpt_tests_to_run }}

  build-result:
    name: Result
    runs-on: ubuntu-latest
    if: always()
    # needs all build to detect cancellation
    needs:
      - "decision"
      - "build"

    steps:
      - name: Mark the job as successful
        if: ${{ !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') }}
        run: exit 0
      - name: Mark the job as unsuccessful
        if: contains(needs.*.result, 'failure') || contains(needs.*.result, 'cancelled')
        run: exit 1
