name: Main

on:
  push:
    # Run the entire pipeline for 'master' even though the merge queue already runs checks
    # for every change. This just offers an extra layer of testing and covers the case of
    # random force pushes.
    branches: ["master", "try"]
  pull_request:
    types: ['opened', 'synchronize']
    branches: ["**"]
  merge_group:
    types: [checks_requested]
  workflow_call:
    inputs:
      configuration:
        required: true
        type: string
  workflow_dispatch:
    inputs:
      profile:
        required: false
        default: false
        type: boolean
      layout:
        required: false
        default: "all"
        type: choice
        options: ["none", "2013", "2020", "all"]
      unit-tests:
        required: false
        default: true
        type: boolean

jobs:
  decision:
    name: Decision
    runs-on: ubuntu-20.04
    outputs:
      configuration: ${{ steps.configuration.outputs.result }}
    steps:
      - name: Configuration
        id: configuration
        uses: actions/github-script@v6
        with:
          script: |
            // If this is a workflow call with a configuration object,
            // then just return it immediately.
            let configuration = ${{ inputs.configuration || '""' }};
            if (configuration != "") {
              console.log("Using configuration: " + JSON.stringify(configuration));
              return configuration;
            }

            // try builds can also have config in last commit msg
            if (${{ github.ref_name == 'try' }}) {
              let commit_msg = context.payload.head_commit.message;
              try {
                var o = JSON.parse(commit_msg.split('\n').slice(-1));

                if (o && typeof o === "object") {
                  console.log("Using try commit configuration: " + JSON.stringify(o));
                  return o;
                }
              }
              catch (e) { }
            }

            if (context.eventName == "pull_request") {
              return {
                "fail_fast": false,
                "matrix": [
                  {
                    "os": "linux",
                    "name": "Linux",
                    "layout": "none",
                    "profile": "release",
                    "unit_tests": true,
                  },
                ],
              };
            }

            // If we reach here we are likely doing full run
            configuration = {
              "fail_fast": false,
              "matrix": [
                {
                  "os": "linux",
                  "name": "Linux",
                  "layout": "all",
                  "profile": "release",
                  "unit_tests": true,
                },
                {
                  "os": "windows",
                  "name": "Windows",
                  "layout": "none", // not used
                  "profile": "release",
                  "unit_tests": true,
                },
                {
                  "os": "mac",
                  "name": "MacOS",
                  "layout": "none",
                  "profile": "release",
                  "unit_tests": true,
                }
              ],
            };

            // Make merge queue fast
            if (context.eventName == "merge_group") {
              configuration.fail_fast = true;
            }

            // override stuff by user provided
            if (context.eventName == "workflow_dispatch") {
              configuration.matrix.linux.layout = "${{ inputs.layout }}";
              let unit_tests = Boolean(${{ inputs.unit-tests }});
              let profile = '${{ inputs.profile }}';
              for (const platform of configuration.matrix) {
                platform.profile = profile;
                platfrom.unit_tests = unit_tests;
              }
            }

            console.log("Using configuration: " + JSON.stringify(configuration));
            return configuration;

  build:
    needs: ["decision"]
    name: ${{ matrix.name }}
    strategy:
      fail-fast: ${{ fromJson(needs.decision.outputs.configuration).fail_fast }}
      matrix:
        include: ${{ fromJson(needs.decision.outputs.configuration).matrix }}
    # we need dipatch os because workflows do not support uses: ${}
    uses: ./.github/workflows/dispatch-os.yml
    secrets: inherit
    with:
      os: ${{ matrix.os }}
      wpt-layout: ${{ matrix.layout }}
      profile: ${{ matrix.profile }}
      unit-tests: ${{ matrix.unit_tests }}

  build-result:
    name: Result
    runs-on: ubuntu-latest
    if: always()
    # needs all build to detect cancellation
    needs:
      - "decision"
      - "build"

    steps:
      - name: Mark the job as successful
        if: ${{ !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') }}
        run: exit 0
      - name: Mark the job as unsuccessful
        if: contains(needs.*.result, 'failure') || contains(needs.*.result, 'cancelled')
        run: exit 1
